\section{Implementacja}

\subsection{Wieloplatformowość}

Przeglądarka jest napisana w taki sposób, że jej implementacja nie uwzględnia systemu operacyjnego na którym pracuje

Zróżnych perspektyw

\subsection{Język programowania}

Przeglądarka została napisana w C++ w standardzie z 2017 roku w skrócie C++17

\subsection{Środowisko programistyczne}

Do programowania głównie używałem CLion, IDE stworzonego przez firmę JetBrians.
Zdecydowana większość czasu przeglądarka była testowana i debugowana na aktualizowanym systemie ArchLinux.

\subsection{Obiektowy model w oprogramowaniu}

Cały projekt jest zaprojektowany w sposób obiektowy, za wyjątkiem kilku pomniejszych elementów.

\subsubsection{DicomScene}

Klasa dziedzicząca pośrednio po \qtclass{QGraphicsScene} przez \sokarclass{Scene}.
Jest to obiektem jednej ramki obrazu i jest odpowiedzialna za pośrednie wygenerowanie obrazu oraz jego wyświetlenie na ekranie.

Informacje na obrazie są wyświetlane za pomocą obiektów \sokarclass{SceneIndicator}.
Obiekty te mają dostęp do bazy danych obrazu DICOM i odpowiednio zmieniają swoją zawartość.

\begin{itemize}

    \item \sokarclass{PatientDataIndicator}

    Obiekt wyświetlający dane pacjenta, pojawia się od zawsze na obrazie i zawiera następujące linie:

    \begin{itemize}
        \item Nazwa pacjenta oraz płeć

        Nazwa pacjenta znajduje się w \dicomtag{PatientName}{0010}{0010}
        Jako, że pacjenta, bądź obiekt badany można nazwać w sposób dowolny i odbiegający od polskiego standardu nazewnictwa, standard DICOM nie przewiduje rozdzielenie poszczególnych składowych nazwy na oznaczone fragmenty.
        Do nazwy osoby został utworzony specjalny VR, \dicomvr{Person Name}{PN}, który dzieli nazwę na podane fragmenty, rozdzielony znakiem \texttt{\^{}} (94 znak kodu ASCII):
        \begin{itemize}
            \item family name complex - nazwisko, np. Smolik
            \item given name complex - imię, np. Adam
            \item middle name - środkowe imię, brak odpowiednika w polskim nazewnictwie
            \item name prefix - prefiks przed imieniem, np: mgr. inż.
            \item name suffix - sufiks po imieniu, brak odpowiednika
        \end{itemize}
        W przypadku mniejszej ilości segmentów, mamy założyć, że są puste
        Na przykład "prof. dr. hab. inż. Waldemar Smolik pracownik ZEJIM" był by zapisany w sposób następujący: \texttt{Smolik\^{}Waldemar\^{}\^{}prof. dr. hab. inż.\^{}pracownik ZEJIM}

        Płeć, zapisana jest w \dicomtag{PatientSex}{0010}{0040} i przedstawiana jest za pomocą znaków UTF-8, "O" i "O", odpowiednio mężczyzny i kobiety.
        W przypadku określenia inne płci niż jest w standardzie bądź braku tagu płeć nie będzie widoczna.

        \item Identyfikator pacjenta

        ID pacjenta z tagu \dicomtag{PatientID}{0010}{0020} wyświetlane w takiej formie jakiej jest zapisane, bez żadnej obróbki.

        \item Data urodzenia oraz wiek pacjenta

        Data urodzenia znajdująca się w , zamieniana jest na format \texttt{yyyy-MM-dd}, czyli rok-miesiąc-dzień.

        Dodatkowo, jeżeli tag jest \dicomtag{PatientAge}{0010}{1010} obecny wyświetlany jest także wiek pacjenta.

        \item TagStudyDescription
        \item TagSeriesDescription
    \end{itemize}

    \item \sokarclass{HospitalDataIndicator}
    \item \sokarclass{ImageOrientationIndicator}
    \item \sokarclass{ModalityIndicator}
    \item \sokarclass{PixelSpacingIndicator}
\end{itemize}

\paragraph{Podział obowiązków w klasie}
\sokarclass{DicomScene} dzieli obowiązki wyświetlania poszczególnych rzeczy innym obiektom, które dziedziczą po \sokarclass

\paragraph{Interfejs generowanie obrazu}
\sokarclass{DicomScene} to klasa abstrakcyjna i nie implementuje sposoby generowania obrazu, ale implementuje interfejs do generowania obrazu, który wykorzystują klasy dziedziczące po \sokarclass{DicomScene}.
Sposoby generowania obrazu są opisane w sekcji ... ;

\paragraph{Informacje o obrazie}
\sokarclass{DicomScene} jest odpowiedzialny za wyświetlenie informacji o obrazie, które nie są zależne od interpretacji woksela obrazu.
Czyli takie jak wielkość obrazka w skali rzeczywistej zapisana w \dicomtag{PixelSpacing}{0028}{0030} określający wielkość woksela w milimetrach.
Szczegóły wyświetlania informacji są zawarte w sekcji ... ;

Funkcjonalność(zajżenć do UML)

Współbierzność

Struktura danych

Dlaczego wektor, a nie drzewo

\subsection{Generowanie obrazów z danych}

Wszystkie obrazy pod koniec nalezy wyświetlić na ekranie. 
Biblioteka QT wymaga aby obrazy do wyświetlania podawać jej za pomocą obiektu klasy \qtclass{QPixmap}, którego można utworzyć z \qtclass{QImage}, który z koleji można wytworzyć z tabilicy wypełnionej pikselami.
Tabilca ta musi mieć strukture RGB888, czyli trzy ośmio bitowe inty, odpowiednio: czerwony, zielony i niebieski.
Tablica ta dalej będzie zawana jako tablicą obrazu(tablica obrazu).

\subsubsection{Monochorme}

Obraz monochromatyczny to obraz w odcieniach szarości, od białego do czarnego lub od czarnego do białego. Dane są zapisane w sposób ciągły wartość po wartości.


Algorytm składa się z dwóch głównych części.
Pierwsza część to wygenerowanie tablicy konwersji, dana na kolor.
Druga to iteracja po wszystkich danych i zamiany ich na kolory za pomocą tablicy wygenerowanej na w kroku pierwszym.


\paragraph{Tablica konwersji, dana na kolor}

Tablica konwersji to tablica, która działa podobnie do tablicy LUT
Alokowana jest tablica struktur \sokarclass{Pixel} o długości 2 do potęgi N, gdzie N jest ilością zaalokowanych bitów danych w obrazie.
Czyli w przypadku 16 bitowego int'a, nie zależnie od posiadania znaku czy nie, 2

\paragraph{Okienkowanie}

Generowanie polega na utworzeniu tablicy LUT i wypełnieniu jej odpowiednimi wartośćiami, tak aby po odwołaniu się do indeksu tablicy równego wartośći danej, zwracany był piksel RGB, czyli taki jaki wyświetlany.

Przyjmijmy, że dane oznaczymy jako oś X.


\paragraph{Okienkowanie}
W okienkowaniu przyjeło się, że podaje się środek okienka oraz jego szerokość, również interferjs użytkowanika pozwala na zmienianie tych parametrów.



Na początku wyliczane są granice okienka na osi X.
Wszystkie wartości, które są po lewo od lewej granicy, otrzymują wartości 0,0f.
Wszystkie wartośći, które są po prawo od lewej granicy, otrzymują wartośći 1,0f.

\begin{itemize}
    \item w przypadku liczb ze znakiem, dodawana jest stała 
    \item given name complex - imię, np. Adam
    \item middle name - środkowe imię, brak odpowiednika w polskim nazewnictwie
    \item name prefix - prefiks przed imieniem, np: mgr. inż.
    \item name suffix - sufiks po imieniu, brak odpowiednika
\end{itemize}


\paragraph{Palety} 
Klasa \sokarclass{Palette} reprezentuje palety kolorów używanych do kolorowania obrazu monochromatycznego.
Mianowicie po paleta przerabia float od zera do jedynki na jakiś kolor, zwracając \sokarclass{Pixel}, który z koleji jest wkładany do tablicy LUT.

\subsubsection{RGB}

Obrazów zapisanych w RGB nie trzeba w żaden sposób obrabiać, dane już są prawie gotowe do wyświetlenia, należy je tylko odpowiednio posortować, tak jak wymaga biblioteka QT.
\qtclass{}

\subsubsection{YBR}