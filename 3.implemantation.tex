\section{Implementacja}

\subsection{Wieloplatformowość}

Przeglądarka jest napisana w taki sposób, że jej implementacja nie uwzględnia systemu operacyjnego na którym pracuje

Zróżnych perspektyw

\subsection{Język programowania}

Przeglądarka została napisana w C++ w standardzie z 2017 roku w skrócie C++17

\subsection{Środowisko programistyczne}

Do programowania głównie używałem CLion, IDE stworzonego przez firmę JetBrians.
Zdecydowana większość czasu przeglądarka była testowana i debugowana na aktualizowanym systemie ArchLinux.

\subsection{Obiektowy model w oprogramowaniu}

Cały projekt jest zaprojektowany w sposób obiektowy, za wyjątkiem kilku pomniejszych elementów.

\subsubsection{Konwertowanie i analiza danych w tagach}

Każdy plik DICOM posiada "Data Set", czyli zbiór informacji składający się z "Data Element".
"Data Element" jest strukturą przechowującą wszystkie dane dotyczące obrazu.

\paragraph{Budowa "Data Element"}

\begin{itemize}
    \item Data Element Tag - to unikalny identyfikator, złożony z dwóch liczb: grupy(uint16) i elementu(uint16) grupy.
    Obiekt używany do przechowywania taga to \gdcmclass{Tag}.
    Informuje o znaczeniu danych.
    Na przykład: jeżeli tag przyjmie wartość \dicomtag{PatientName}{0010}{0010}, oznacza to, że dane w "Data Element" zawierają nazwę pacjenta.
    \item Value Representation, w skrócie VR – typ danych umożliwiający poprawną interpretację danych.
    Informuje w jaki sposób dane są zapisane.
    Obiekt używany do przechowywania taga to \gdcmclass{VR}.
    Na przykład: Decimal String, w skrócie DS, oznacza liczbę zapisaną za pomocą teksu.
    Czasami to pole może być puste, wtedy należy się odnieść do VR przypisanego do taga, który określa standard.
    \item Value Length, w skrócie VL – rozmiar elementu
    \item Value Field (opcjonalne) – pole z właściwymi danymi
\end{itemize}

\paragraph{Konwerter}

Obiekt klasy \sokarclass{DataConverter} to obiekt zajmujący się konwersją danych z pliku DICOM na dane w formacie odpowiadającej przeglądarce.

Kilka rzeczy które się tyczą wszystkich danych i konwersji:
\begin{itemize}
    \item większość VR jest to zapisane jako tekst, kodowanie i dekodowanie tekstu jest zapewniane przez bibliotekę, a konkretniej przez klasę \gdcmclass{StringFilter}, dlatego nie przejmuje się takimi rzeczami jak zapisem LittleEndian i BigEndian.
    \item większość danych może mieć kilka wartości oddzielonych backslashem "\textbackslash", dlatego konwerter dla VR w, których standard przewiduje wiele wartości, zawsze zwraca \qtclass{QVector} z tymi wartościami
\end{itemize}

Klasa obsługuje następujące VR:
\begin{itemize}
    \item AS - Age String - wiek lub długość życia\\
    Długość danych zawsze wynosi 4 bajty.
    Pierwsze trzy bajty to liczba całkowita zapisana za pomocą tekstu.
    Czwarty bajt to znaku określający jednostkę czasu.
    Standard definiuje cztery możliwe jednostki czasu: "D" jako dzień, "W" jako tydzień, "M" jako miesiąc, oraz "Y" jako jeden rok.
    Konwerter zmienia tą wartość na tekst w postaci czytelnej, np: "18 weeks" lub "3 years", oraz jest wrażliwy na obecny język aplikacji.
    \\\\
    Przykład: "018M" oznacza 18 miesięcy, "123D" oznacza 123 dni.

    \item AT - Attribute Tag - inny tag
    Długość danych to zawsze 32 bity, są to dwie 16 bitowe liczby.
    Odpowiednio grupa i element grupy.
    Ten VR jest używany kiedy wskazujemy na inny tag.
    Wartość nie jest nigdy pokazywana użytkownikowi, a jedynie używana w interpretacji przez algotyrm tworzenia filmu.
    \\\\
    Przykład: tag \dicomtag{FrameIncrementPointer}{0028}{0009} jest używany kiedy w pliku jest zapisana sekwencja kilku obrazów, wskazuje on na inny tag zawierający informacje w jaki sposób ta sekwencja ma być wyświetlona.
    
    \item DA - Date - data lub dzień
    Długość danych zawsze wynosi 8 bajtów.
    Data zapisana w formacie YYYYMMDD, gdzie: YYYY cztery cyfry roku, MM cztery cyfry miesiąca, DD dwie cyfry dnia w kalendarzu Gregoriańskim.
    Konwerter zamienia dane na obiekt klasy \qtclass{QDate}, który ma w sobie wbudowaną konwersję na tekst zależny od ustawień językowych aplikacji.
    \\\\
    Przykład: "19800716" oznacza 16 lipca 1980
    \\\\
    UWAGA: Standard "ACR-NEMA Standard 300", czyli poprzednik DICOM definiował date w sposób "YYYY.MM.DD", według standardu DICOM, taki zapis jest nie poprawny, ale zdarzają się stare obrazy z takimi datami i \sokarclass{DataConverter} obsługuje taki format.

    \item DS - Decimal String - liczba zmienno przecinkowa lub ciąg kilku liczb zmienno przecinkowych zapisanych za pomocą tekstu w notacji wykładniczej
    Długość jednej liczby powinna maksymalne wynosić 16 bajtów.
    Dostępne znaki to "0"-"9", "+", "-", "E", "e", ".".
    Biblioteka QT posiada wbudowany konwerter takich liczb, dlatego mój konwerter dzieli tekst i konwertuje za pomocą QT.
    \\\\
    Przykład:

    \item IS
    \item PN
    \item SS
    \item US    
    \item UT
\end{itemize}

\subsubsection{DicomScene}

Klasa dziedzicząca pośrednio po \qtclass{QGraphicsScene} przez \sokarclass{Scene}.
Jest to obiektem jednej ramki obrazu i jest odpowiedzialna za pośrednie wygenerowanie obrazu oraz jego wyświetlenie na ekranie.

Informacje na obrazie są wyświetlane za pomocą obiektów \sokarclass{SceneIndicator}.
Obiekty te mają dostęp do bazy danych obrazu DICOM i odpowiednio zmieniają swoją zawartość.

\begin{itemize}

    \item \sokarclass{PatientDataIndicator}

    Obiekt wyświetlający dane pacjenta, pojawia się od zawsze na obrazie i zawiera następujące linie:

    \begin{itemize}
        \item Nazwa pacjenta oraz płeć

        Nazwa pacjenta znajduje się w \dicomtag{PatientName}{0010}{0010}
        Jako, że pacjenta, bądź obiekt badany można nazwać w sposób dowolny i odbiegający od polskiego standardu nazewnictwa, standard DICOM nie przewiduje rozdzielenie poszczególnych składowych nazwy na oznaczone fragmenty.
        Do nazwy osoby został utworzony specjalny VR, \dicomvr{Person Name}{PN}, który dzieli nazwę na podane fragmenty, rozdzielony znakiem \texttt{\^{}} (94 znak kodu ASCII):
        \begin{itemize}
            \item family name complex - nazwisko, np. Smolik
            \item given name complex - imię, np. Adam
            \item middle name - środkowe imię, brak odpowiednika w polskim nazewnictwie
            \item name prefix - prefiks przed imieniem, np: mgr. inż.
            \item name suffix - sufiks po imieniu, brak odpowiednika
        \end{itemize}
        W przypadku mniejszej ilości segmentów, mamy założyć, że są puste
        Na przykład "prof. dr. hab. inż. Waldemar Smolik pracownik ZEJIM" był by zapisany w sposób następujący: \texttt{Smolik\^{}Waldemar\^{}\^{}prof. dr. hab. inż.\^{}pracownik ZEJIM}

        Płeć, zapisana jest w \dicomtag{PatientSex}{0010}{0040} i przedstawiana jest za pomocą znaków UTF-8, "O" i "O", odpowiednio mężczyzny i kobiety.
        W przypadku określenia inne płci niż jest w standardzie bądź braku tagu płeć nie będzie widoczna.

        \item Identyfikator pacjenta

        ID pacjenta z tagu \dicomtag{PatientID}{0010}{0020} wyświetlane w takiej formie jakiej jest zapisane, bez żadnej obróbki.

        \item Data urodzenia oraz wiek pacjenta

        Data urodzenia znajdująca się w , zamieniana jest na format \texttt{yyyy-MM-dd}, czyli rok-miesiąc-dzień.

        Dodatkowo, jeżeli tag jest \dicomtag{PatientAge}{0010}{1010} obecny wyświetlany jest także wiek pacjenta.

        \item TagStudyDescription
        \item TagSeriesDescription
    \end{itemize}

    \item \sokarclass{HospitalDataIndicator}
    \item \sokarclass{ImageOrientationIndicator}
    \item \sokarclass{ModalityIndicator}
    \item \sokarclass{PixelSpacingIndicator}
\end{itemize}

\paragraph{Podział obowiązków w klasie}
\sokarclass{DicomScene} dzieli obowiązki wyświetlania poszczególnych rzeczy innym obiektom, które dziedziczą po \sokarclass

\paragraph{Interfejs generowanie obrazu}
\sokarclass{DicomScene} to klasa abstrakcyjna i nie implementuje sposoby generowania obrazu, ale implementuje interfejs do generowania obrazu, który wykorzystują klasy dziedziczące po \sokarclass{DicomScene}.
Sposoby generowania obrazu są opisane w sekcji ... ;

\paragraph{Informacje o obrazie}
\sokarclass{DicomScene} jest odpowiedzialny za wyświetlenie informacji o obrazie, które nie są zależne od interpretacji woksela obrazu.
Czyli takie jak wielkość obrazka w skali rzeczywistej zapisana w \dicomtag{PixelSpacing}{0028}{0030} określający wielkość woksela w milimetrach.
Szczegóły wyświetlania informacji są zawarte w sekcji ... ;

Funkcjonalność(zajżenć do UML)

Współbierzność

Struktura danych

Dlaczego wektor, a nie drzewo

\subsection{Generowanie obrazów z danych}

Wszystkie obrazy pod koniec nalezy wyświetlić na ekranie. 
Biblioteka QT wymaga aby obrazy do wyświetlania podawać jej za pomocą obiektu klasy \qtclass{QPixmap}, którego można utworzyć z \qtclass{QImage}, który z koleji można wytworzyć z tabilicy wypełnionej pikselami.
Tabilca ta musi mieć strukture RGB888, czyli trzy ośmio bitowe inty, odpowiednio: czerwony, zielony i niebieski.
Tablica ta dalej będzie zawana jako tablicą obrazu(tablica obrazu).

\subsubsection{Monochorme}

Obraz monochromatyczny to obraz w odcieniach szarości, od białego do czarnego lub od czarnego do białego. Dane są zapisane w sposób ciągły wartość po wartości.


Algorytm składa się z dwóch głównych części.
Pierwsza część to wygenerowanie tablicy konwersji, dana na kolor.
Druga to iteracja po wszystkich danych i zamiany ich na kolory za pomocą tablicy wygenerowanej na w kroku pierwszym.


\paragraph{Palety} 
Klasa \sokarclass{Palette} reprezentuje palety kolorów używanych do kolorowania obrazu monochromatycznego.
Mianowicie po paleta przerabia liczbe zmiennoprzecinokowa od zera do jedynki na jakiś kolor, zwracając \sokarclass{Pixel}, który z koleji jest wkładany do tablicy okienka.

\paragraph{Tablica okienka, wartość na kolor}

Tablica konwersji to tablica, która jest tak na prawde tablicą LUT(Look Up Table), tylko, że w naszym przypadku zmienia ona wartość obrazu na piksel.
Alokowana jest tablica struktur \sokarclass{Pixel} o długości 2 do potęgi N, gdzie N jest ilością zaalokowanych bitów, która jest pobrana z \dicomtag{BitsAllocated}{0028}{0100}.
Czyli w przypadku 16 bitowego int'a, nie zależnie od posiadania znaku czy nie, zostanie zaalokowanych 65536 struktur \sokarclass{Pixel}, czyli 196608 bajtów.
Ta operacja jest jedno razowa.

\paragraph{Wyznaczanie okienka}
Najpierw wyznaczam okienko, które zmienia wartości obrazu na skale od zera do jeden:
\[x_0 = center - width / 2\]
\[x_1 = center + width / 2\]
\[y_1 = 0.0\]
\[y_0 = 1.0\]
gdzie:
\begin{conditions}
center  &   środek okienka \\
width   &   szerokość okienka \\
x0, y0  &   współżędne pierwszego punktu \\
x1, y1  &   współżędne drugego punktu
\end{conditions}
Przeglądarka pozwala na inwersje okienka.
Dlatego kiedy użytkownik zażyczy sobie inwersji, zmienne y\textsubscript{0} i y\textsubscript{1} zamienią się wartoścami.

Standart DICOM przewiduje, że wszystkie dane powinny być wyskalowane, za pomocą wzoru.
\[OutputUnits = m*SV + b\]
gdzie:
\begin{conditions}
m           &    warość z \dicomtag{RescaleSlope}{0028}{1053} \\
b           &    warość z \dicomtag{RescaleIntercept}{0028}{1052} \\
SV          &    stored values - warość pixela z pliku  \\
OutputUnits &    wartość wynikowa
\end{conditions}

Wartości okienka odnoszą się do wartości już wyskalowanej, a ponieważ skalowanie całego obrazu jest czasochłonne, przeskalowaie okienka da taki sam efekt:
\[(OutputUnits - b ) / m = SV \]
więc:
\[x_0 -= rescaleIntercept\]
\[x_1 -= rescaleIntercept\]
\[x_0 /= rescaleSlope\]
\[x_1 /= rescaleSlope\]

Posiadamy, teraz dwa punkty okienka odnoszące się do wartośći obrazu.
Wyznaczam parametry prostej przechodzącej przez dwa punkty:
\[a = (y_1 - y_0) / (x_1 - x_0)\]
\[b = y_1 - a * x_1\]

Teraz iterujemy po wszystkich możliwych wartościach wartośćiach obrazu i wykonujemy takie operacje.
\begin{itemize}
    \item wyznaczenie wartości okienka.
    \[y = a * x + b\]
    \item y zostaje obcięcie do 1.0 lub 0.0 jeżeli wyjdzie poza zakres od 1.0 do 0.0
    \item pobranie z palety piksel odpowiadający wartości
    \item wsadzenie piksela do tablicy, tak aby najmniejsza wartości obrazu miała indeks 0 a największy ostani
\end{itemize}

\subsubsection{RGB}

Obrazów zapisanych w RGB nie trzeba w żaden sposób obrabiać, dane już są prawie gotowe do wyświetlenia, należy je tylko odpowiednio posortować, tak jak wymaga biblioteka QT.
Sposób posortowania wartości w pilku określa \dicomtag{PlanarConfiguration}{0x0028}{0006}. Może o przyjąć dwie następujące wartośći:

\begin{itemize}
    \item 0 - oznacza to, że wartości pikseli są ułożone w taki sposób
        \[R1, G1, B1, R2, G2, B2, R3, G3, B3, R4, G4, B4,  ...\]
    \item 1 - oznacza to, że wartości pikseli są ułożone w taki sposób
        \[R1, R2, R3, R4, ... , G1, G2, G3, G4, ..., B1, B2, B3, B4, ...\]
\end{itemize}
gdzie:
\begin{conditions}
Rn  &   wartość czerwonego kanału \\
Gn  &   wartość zielonego kanału \\
Bn  &   wartość niebieskiego kanału
\end{conditions}

Wartości obrazu są przepisywane do buffora dla biblioteki QT.

\subsubsection{YBR}

Skórt YBR odpowiada skrótowi YCbCr.
Wartości są ułożone w taki sposób.
\[Y1, B1, R1, Y2, B2, R2, Y3, B3, R3, Y4, B4, R4,  ...\]

Ponieważ wartości te reprezentują kolory, są już w pewnym sensie są obrazem, ale nie można go wyświetlić, ponieważ komputery bazują na kolorach RGB.
Dlatego odpowieni algorytm konwertuje kolor YBR na kolor RGB, iterując po wszystkich wartościach obrazu.

\paragraph{Konwersja koloru YBR na kolor RGB}

YBR albo YCbCr to model przestrzeni kolorów do przechowywania obrazów i wideo.
Wykorzystuje do tego trzy typy danych: Y – składową luminancji, B lub Cb – składową różnicową chrominancji Y-B, stanowiącą różnicę między luminancją a niebieskim, oraz R lub Cr – składową chrominancji Y-R, stanowiącą różnicę między luminancją a czerwonym.
Kolor zielony jest uzyskiwany na podstawie tych trzech wartości.
YBR nie pokrywa w całości RGB, tak jak RGB nie pokrywa YBR.
Posiadają one część wspólną, co uniemożliwia wyświetlenie obrazu w stu procentach bez zniekształceń.
